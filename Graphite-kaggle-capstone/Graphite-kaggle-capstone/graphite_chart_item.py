"""
This module defines the ChartItem class, which is responsible for rendering
data visualizations (Bar, Line, Pie, Sankey, etc.) using Matplotlib within
the QGraphicsScene.
"""

import matplotlib
# Use the 'Agg' backend for Matplotlib to render figures to a buffer without
# creating an interactive window, which is essential for embedding in Qt.
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg
from matplotlib.figure import Figure

from PySide6.QtWidgets import QGraphicsItem
from PySide6.QtCore import (
    Qt, QRectF, QPointF, QSizeF
)
from PySide6.QtGui import (
    QPainter, QColor, QBrush, QPen, QPainterPath, QImage,
    QLinearGradient, QFont, QFontMetrics
)

from graphite_config import get_current_palette
# Import Container for type checking in itemChange
from graphite_canvas_items import Container

class ChartItem(QGraphicsItem):
    """
    A QGraphicsItem that renders a data chart using Matplotlib.
    It takes a structured data dictionary and generates a chart image, which is
    then displayed on the canvas.
    """
    PADDING = 20
    HEADER_HEIGHT = 40
    
    def __init__(self, data, pos, parent=None):
        """
        Initializes the ChartItem.

        Args:
            data (dict): The structured data for the chart, as generated by ChartDataAgent.
            pos (QPointF): The initial position of the chart on the scene.
            parent (QGraphicsItem, optional): The parent item. Defaults to None.
        """
        super().__init__(parent)
        self.setPos(pos)
        self.data = data
        self.title = data.get('title', 'Chart')
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges)
        self.setAcceptHoverEvents(True)
        
        self.width = 650
        self.height = 500
        
        self.hovered = False
        self.resize_handle_hovered = False
        self.resizing = False
        self.sankey_geometry = None
        
        # Interaction state for Sankey
        self.hovered_node_idx = -1
        self.hovered_link_idx = -1
        self.hover_pos = QPointF()
        
        # Set up the Matplotlib figure and canvas.
        self.figure = Figure(figsize=(6, 4), dpi=300)
        self.figure.patch.set_facecolor('#2d2d2d')
        self.canvas = FigureCanvasQTAgg(self.figure)
        self.canvas.setStyleSheet("background-color: transparent;")
        
        self.generate_chart()

    def layout_sankey(self):
        flows = self.data.get('flows', [])
        if not flows:
            self.sankey_geometry = None
            return

        # --- 1. Process Nodes and Flows ---
        nodes = {}
        
        for f in flows:
            src = str(f.get('source', '?'))
            tgt = str(f.get('target', '?'))
            val = float(f.get('value', 0))
            
            if src not in nodes: nodes[src] = {'in': 0, 'out': 0, 'level': 0, 'name': src}
            if tgt not in nodes: nodes[tgt] = {'in': 0, 'out': 0, 'level': 0, 'name': tgt}
            
            nodes[src]['out'] += val
            nodes[tgt]['in'] += val

        # --- 2. Assign Levels (Topological Sort) ---
        roots = [n for n, data in nodes.items() if data['in'] == 0]
        if not roots and nodes: roots = [list(nodes.keys())[0]] # Cycle fallback

        adj = {n: [] for n in nodes}
        for f in flows:
            adj[str(f.get('source', '?'))].append(str(f.get('target', '?')))

        queue = [(n, 0) for n in roots]
        
        # Reset levels
        for n in nodes: nodes[n]['level'] = 0
        
        max_level = 0
        while queue:
            curr, lvl = queue.pop(0)
            if lvl > nodes[curr]['level']:
                nodes[curr]['level'] = lvl
            max_level = max(max_level, lvl)
            
            for neighbor in adj[curr]:
                if nodes[neighbor]['level'] <= lvl: 
                    queue.append((neighbor, lvl + 1))

        # Group by level
        level_groups = {}
        for name, data in nodes.items():
            lvl = data['level']
            if lvl not in level_groups: level_groups[lvl] = []
            level_groups[lvl].append(name)

        # --- 3. Sizing Calculations ---
        font = QFont("Segoe UI", 9)
        metrics = QFontMetrics(font)
        node_spacing = 30 # Vertical gap between nodes
        node_min_height = 20
        
        # Calculate required height for each column
        max_col_height = 0
        for lvl, names in level_groups.items():
            col_text_height = 0
            for name in names:
                col_text_height += metrics.height() + node_spacing
            min_col_req = col_text_height + (len(names) * node_min_height)
            max_col_height = max(max_col_height, min_col_req)

        # Auto-Resize ChartItem if needed
        req_height = max_col_height + self.HEADER_HEIGHT + 150 
        req_width = max(600, (max_level + 1) * 250)
        
        geometry_changed = False
        if req_height > self.height:
            self.height = req_height
            geometry_changed = True
        if req_width > self.width:
            self.width = req_width
            geometry_changed = True
            
        if geometry_changed:
            self.prepareGeometryChange()

        # Layout Params
        margin_top = self.HEADER_HEIGHT + 70
        margin_bottom = 70
        margin_side = 20
        
        draw_area_left = margin_side + 150 # Space for left labels
        draw_area_right = self.width - (margin_side + 150) # Space for right labels
        draw_area_width = draw_area_right - draw_area_left
        draw_area_height = self.height - margin_top - margin_bottom
        
        # Calculate Pixels per Value (Ky)
        max_vol_in_level = 0
        for lvl, names in level_groups.items():
            lvl_vol = sum(max(nodes[n]['in'], nodes[n]['out']) for n in names)
            max_vol_in_level = max(max_vol_in_level, lvl_vol)
            
        max_nodes = max(len(g) for g in level_groups.values())
        total_spacing_loss = (max_nodes - 1) * node_spacing
        
        Ky = 0
        if max_vol_in_level > 0:
            Ky = (draw_area_height - total_spacing_loss) / max_vol_in_level
            
        # --- 4. Geometry Generation ---
        self.sankey_geometry = {'nodes': [], 'links': []}
        
        # Generate Colors
        palette_colors = list(get_current_palette().FRAME_COLORS.values())
        full_colors = [c['color'] for c in palette_colors if c['type'] == 'full']
        color_map = {}
        for i, name in enumerate(nodes.keys()):
            color_map[name] = QColor(full_colors[i % len(full_colors)])

        node_rects = {} # name -> QRectF
        col_step = draw_area_width / max(1, max_level)
        
        # Place Nodes
        for lvl in range(max_level + 1):
            names = level_groups.get(lvl, [])
            col_flow_height = 0
            for name in names:
                val = max(nodes[name]['in'], nodes[name]['out'])
                col_flow_height += max(node_min_height, val * Ky)
            
            total_col_h = col_flow_height + (len(names) - 1) * node_spacing
            y_start = margin_top + (draw_area_height - total_col_h) / 2
            x = draw_area_left + (lvl * col_step)
            
            if lvl == max_level and max_level > 0:
                x = draw_area_right - 20 
                
            current_y = y_start
            
            for name in names:
                val = max(nodes[name]['in'], nodes[name]['out'])
                h = max(node_min_height, val * Ky)
                w = 20 
                
                rect = QRectF(x, current_y, w, h)
                node_rects[name] = rect
                
                label_align = Qt.AlignmentFlag.AlignCenter
                label_pos = QPointF(rect.center().x(), rect.top() - 15)
                
                if lvl == 0:
                    label_align = Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
                    label_pos = QPointF(rect.left() - 10, rect.center().y())
                elif lvl == max_level:
                    label_align = Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter
                    label_pos = QPointF(rect.right() + 10, rect.center().y())
                else:
                    label_align = Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignBottom
                    label_pos = QPointF(rect.center().x(), rect.top() - 5)

                self.sankey_geometry['nodes'].append({
                    'rect': rect,
                    'label': name,
                    'color': color_map[name],
                    'label_pos': label_pos,
                    'label_align': label_align,
                    'value': val
                })
                
                current_y += h + node_spacing

        # Place Links (Variable Width Ribbons)
        
        # Sort flows to untangle tracks
        def get_flow_sort_key(f):
            src = str(f.get('source', '?'))
            tgt = str(f.get('target', '?'))
            src_y = node_rects[src].center().y() if src in node_rects else 0
            tgt_y = node_rects[tgt].center().y() if tgt in node_rects else 0
            return (src_y, tgt_y)

        sorted_flows = sorted(flows, key=get_flow_sort_key)
        
        node_offsets_in = {n: 0.0 for n in nodes}
        node_offsets_out = {n: 0.0 for n in nodes}

        for f in sorted_flows:
            src = str(f.get('source', '?'))
            tgt = str(f.get('target', '?'))
            val = float(f.get('value', 0))
            if val <= 0: continue
            
            src_rect = node_rects.get(src)
            tgt_rect = node_rects.get(tgt)
            
            if not src_rect or not tgt_rect: continue
            
            src_total = max(nodes[src]['in'], nodes[src]['out'])
            tgt_total = max(nodes[tgt]['in'], nodes[tgt]['out'])
            
            src_h = src_rect.height() * (val / src_total) if src_total > 0 else 0
            tgt_h = tgt_rect.height() * (val / tgt_total) if tgt_total > 0 else 0
            
            sy = src_rect.top() + node_offsets_out[src] + (src_h / 2)
            ty = tgt_rect.top() + node_offsets_in[tgt] + (tgt_h / 2)
            
            node_offsets_out[src] += src_h
            node_offsets_in[tgt] += tgt_h
            
            # Construct Polygon Path for Ribbon
            path = QPainterPath()
            
            # Top curve
            start_pt = QPointF(src_rect.right(), sy - src_h/2)
            end_pt = QPointF(tgt_rect.left(), ty - tgt_h/2)
            
            path.moveTo(start_pt)
            dx = (end_pt.x() - start_pt.x()) / 2
            path.cubicTo(
                QPointF(start_pt.x() + dx, start_pt.y()),
                QPointF(end_pt.x() - dx, end_pt.y()),
                end_pt
            )
            
            # Bottom line/curve back
            bottom_end_pt = QPointF(tgt_rect.left(), ty + tgt_h/2)
            bottom_start_pt = QPointF(src_rect.right(), sy + src_h/2)
            
            path.lineTo(bottom_end_pt)
            path.cubicTo(
                QPointF(bottom_end_pt.x() - dx, bottom_end_pt.y()),
                QPointF(bottom_start_pt.x() + dx, bottom_start_pt.y()),
                bottom_start_pt
            )
            path.closeSubpath()
            
            # Create a separate hit path if needed, or reuse polygon
            # For variable width, the polygon itself is the best hit test
            
            self.sankey_geometry['links'].append({
                'path': path,
                'hit_path': path,
                'color_start': color_map[src],
                'color_end': color_map[tgt],
                'label': f"{src} â†’ {tgt}",
                'value': val,
                'width': 1 # Used for drawing gradient, actual width is in path
            })

    def hoverMoveEvent(self, event):
        if self.sankey_geometry:
            pos = event.pos()
            self.hover_pos = pos
            self.hovered_node_idx = -1
            self.hovered_link_idx = -1
            
            for i, node in enumerate(self.sankey_geometry['nodes']):
                if node['rect'].contains(pos):
                    self.hovered_node_idx = i
                    self.update()
                    super().hoverMoveEvent(event)
                    return

            for i, link in enumerate(self.sankey_geometry['links']):
                if link['hit_path'].contains(pos):
                    self.hovered_link_idx = i
                    self.update()
                    super().hoverMoveEvent(event)
                    return
            
            self.update()

        super().hoverMoveEvent(event)

    def draw_sankey(self, painter):
        if not hasattr(self, 'sankey_geometry') or not self.sankey_geometry:
            return

        palette = get_current_palette()
        
        focus_active = (self.hovered_node_idx != -1) or (self.hovered_link_idx != -1)
        dim_alpha = 40 if focus_active else 150 
        
        # 1. Draw Links (Ribbons)
        for i, link in enumerate(self.sankey_geometry['links']):
            is_hovered = (i == self.hovered_link_idx)
            
            connected_to_hovered_node = False
            if self.hovered_node_idx != -1:
                n_color = self.sankey_geometry['nodes'][self.hovered_node_idx]['color']
                if link['color_start'] == n_color or link['color_end'] == n_color:
                    connected_to_hovered_node = True

            should_highlight = is_hovered or connected_to_hovered_node
            alpha = 200 if should_highlight else (dim_alpha if focus_active else 100)
            
            path = link['path']
            rect = path.boundingRect()
            gradient = QLinearGradient(rect.topLeft(), rect.topRight())
            
            c_start = QColor(link['color_start'])
            c_start.setAlpha(alpha)
            c_end = QColor(link['color_end'])
            c_end.setAlpha(alpha)
            
            gradient.setColorAt(0, c_start)
            gradient.setColorAt(1, c_end)
            
            painter.setPen(Qt.PenStyle.NoPen)
            painter.setBrush(QBrush(gradient))
            painter.drawPath(path)
            
            if is_hovered:
                outline_pen = QPen(QColor(255, 255, 255, 100), 1)
                painter.setPen(outline_pen)
                painter.setBrush(Qt.BrushStyle.NoBrush)
                painter.drawPath(path)

        # 2. Draw Nodes
        font = QFont("Segoe UI", 8)
        painter.setFont(font)
        
        for i, node in enumerate(self.sankey_geometry['nodes']):
            is_hovered = (i == self.hovered_node_idx)
            
            connected_to_hovered_link = False
            if self.hovered_link_idx != -1:
                link = self.sankey_geometry['links'][self.hovered_link_idx]
                if link['color_start'] == node['color'] or link['color_end'] == node['color']:
                    connected_to_hovered_link = True
            
            should_highlight = is_hovered or connected_to_hovered_link
            
            rect = node['rect']
            color = QColor(node['color'])
            
            if not should_highlight and focus_active:
                color.setAlpha(100)
            else:
                color.setAlpha(255)

            if should_highlight:
                painter.setPen(Qt.PenStyle.NoPen)
                painter.setBrush(QColor(0,0,0, 100))
                painter.drawRoundedRect(rect.translated(2, 2), 4, 4)

            painter.setPen(Qt.PenStyle.NoPen)
            painter.setBrush(color)
            painter.drawRoundedRect(rect, 4, 4)
            
            if is_hovered:
                painter.setPen(QPen(QColor("white"), 1.5))
                painter.setBrush(Qt.BrushStyle.NoBrush)
                painter.drawRoundedRect(rect, 4, 4)

            painter.setPen(QColor("white"))
            if not should_highlight and focus_active:
                 painter.setPen(QColor(255, 255, 255, 100))

            label_pos = node['label_pos']
            text_rect = QRectF(label_pos.x() - 100, label_pos.y() - 15, 200, 30)
            painter.drawText(text_rect, node['label_align'], node['label'])

        # 3. Draw Tooltip
        if self.hovered_node_idx != -1:
            node = self.sankey_geometry['nodes'][self.hovered_node_idx]
            self._draw_tooltip(painter, self.hover_pos, [
                f"Node: {node['label']}",
                f"Total Flow: {node['value']:,.1f}"
            ])
        elif self.hovered_link_idx != -1:
            link = self.sankey_geometry['links'][self.hovered_link_idx]
            self._draw_tooltip(painter, self.hover_pos, [
                f"{link['label']}",
                f"Value: {link['value']:,.1f}"
            ])

    def _draw_tooltip(self, painter, pos, lines):
        painter.save()
        font = QFont("Segoe UI", 9)
        painter.setFont(font)
        metrics = QFontMetrics(font)
        
        line_height = metrics.height()
        max_w = 0
        for line in lines:
            max_w = max(max_w, metrics.horizontalAdvance(line))
            
        w = max_w + 20
        h = (len(lines) * line_height) + 10
        
        rect = QRectF(pos.x() + 15, pos.y() + 15, w, h)
        if rect.right() > self.width: rect.moveRight(pos.x() - 5)
        if rect.bottom() > self.height: rect.moveBottom(pos.y() - 5)
        
        painter.setPen(QPen(QColor("#555"), 1))
        painter.setBrush(QColor(30, 30, 30, 240))
        painter.drawRoundedRect(rect, 4, 4)
        
        painter.setPen(QColor("white"))
        y = rect.top() + 5 + metrics.ascent()
        for line in lines:
            painter.drawText(QPointF(rect.left() + 10, y), line)
            y += line_height
            
        painter.restore()

    def generate_chart(self):
        palette = get_current_palette()
        def abbreviate_text(text):
            if not isinstance(text, str): return str(text)
            words = text.split()
            abbreviated = [word[:3].lower() if len(word) > 8 else word for word in words]
            return ' '.join(abbreviated)

        self.figure.clear()
        ax = self.figure.add_subplot(111)
        ax.set_facecolor('#2d2d2d')
    
        plt.style.use('dark_background')
    
        plt.rcParams['axes.labelsize'] = 8
        plt.rcParams['axes.titlesize'] = 8
        plt.rcParams['xtick.labelsize'] = 7
    
        chart_type = self.data.get('type', '')
        
        try:
            if chart_type == 'sankey':
                self.layout_sankey()
                return

            else:
                labels = [abbreviate_text(str(label)) for label in self.data.get('labels', [])]
                values = self.data.get('values', [])
                xaxis, yaxis = abbreviate_text(self.data.get('xAxis', '')), abbreviate_text(self.data.get('yAxis', ''))
            
                if chart_type == 'bar':
                    bars = ax.bar(labels, values, color=palette.USER_NODE.name())
                    ax.set_xlabel(xaxis); ax.set_ylabel(yaxis)
                    for bar in bars:
                        height = bar.get_height()
                        ax.text(bar.get_x() + bar.get_width()/2., height, f'{height:,.1f}', ha='center', va='bottom', fontsize=7)
                
                elif chart_type == 'line':
                    ax.plot(labels, values, color=palette.AI_NODE.name(), marker='o', linewidth=2, markersize=6, markerfacecolor='white')
                    ax.set_xlabel(xaxis); ax.set_ylabel(yaxis)
                
                elif chart_type == 'pie':
                    colors = [palette.USER_NODE.name(), palette.AI_NODE.name(), "#9b59b6", "#e67e22", "#e74c3c", palette.NAV_HIGHLIGHT.name()]
                    wedges, texts, autotexts = ax.pie(values, labels=labels, autopct='%1.1f%%', colors=colors, textprops={'fontsize': 7, 'color': 'white'}, wedgeprops={'linewidth': 1, 'edgecolor': '#2d2d2d'})
                    plt.setp(autotexts, weight="bold", size=7); plt.setp(texts, weight="bold", size=7)
                
                elif chart_type == 'histogram':
                    ax.hist(values, bins=self.data.get('bins', 10), color=palette.NAV_HIGHLIGHT.darker(120).name(), edgecolor='white', linewidth=1)
                    ax.set_xlabel(xaxis); ax.set_ylabel(yaxis)
                    ax.grid(True, linestyle='--', alpha=0.3, linewidth=0.5)
                
                if chart_type in ['bar', 'line']: plt.xticks(rotation=45, ha='right')

        except Exception as e:
            ax.clear()
            ax.axis('off')
            error_msg = f"Error generating chart:\n{str(e)}"
            ax.text(0.5, 0.5, error_msg, ha='center', va='center', color='#e74c3c', wrap=True, fontsize=9)
    
        self.figure.tight_layout(pad=1.8)
    
        self.canvas.draw()
        width, height = self.canvas.get_width_height()
        self.chart_image = QImage(self.canvas.buffer_rgba(), width, height, QImage.Format.Format_RGBA8888)
    
        if hasattr(self.chart_image, 'setDevicePixelRatio'):
            self.chart_image.setDevicePixelRatio(2.0)
        
    def boundingRect(self):
        return QRectF(0, 0, self.width, self.height)
        
    def paint(self, painter, option, widget=None):
        palette = get_current_palette()
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.setRenderHint(QPainter.RenderHint.TextAntialiasing)
        painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)
        
        shadow_path = QPainterPath(); shadow_path.addRoundedRect(3, 3, self.width, self.height, 10, 10)
        painter.setPen(Qt.PenStyle.NoPen); painter.setBrush(QColor(0, 0, 0, 30)); painter.drawPath(shadow_path)
        path = QPainterPath(); path.addRoundedRect(0, 0, self.width, self.height, 10, 10)
        if self.isSelected(): painter.setPen(QPen(palette.SELECTION, 2))
        elif self.hovered: painter.setPen(QPen(QColor("#ffffff"), 2))
        else: painter.setPen(QPen(QColor("#555555")))
        painter.setBrush(QBrush(QColor("#2d2d2d"))); painter.drawPath(path)
        header_rect = QRectF(0, 0, self.width, self.HEADER_HEIGHT)
        header_path = QPainterPath(); header_path.addRoundedRect(header_rect, 10, 10)
        header_gradient = QLinearGradient(header_rect.topLeft(), header_rect.bottomLeft())
        header_color = palette.AI_NODE
        header_gradient.setColorAt(0, header_color); header_gradient.setColorAt(1, header_color.darker(110))
        painter.setBrush(QBrush(header_gradient)); painter.drawPath(header_path)
        
        painter.setPen(QPen(QColor("#ffffff")))
        font = QFont("Segoe UI", 10, QFont.Weight.Bold); painter.setFont(font)
        painter.drawText(header_rect.adjusted(10, 0, -10, 0), Qt.AlignmentFlag.AlignVCenter, self.title)
        
        chart_type = self.data.get('type', '')
        
        if chart_type == 'sankey':
             self.draw_sankey(painter)
        elif hasattr(self, 'chart_image'):
            chart_rect = QRectF(self.PADDING, self.HEADER_HEIGHT + 10, self.width - (self.PADDING * 2), self.height - self.HEADER_HEIGHT - (self.PADDING * 2))
            painter.drawImage(chart_rect, self.chart_image)
            
        if self.hovered or self.isSelected():
            handle_size = 10
            handle_rect = QRectF(self.width - handle_size, self.height - handle_size, handle_size, handle_size)
            painter.setPen(QPen(QColor("#ffffff")))
            painter.drawLine(handle_rect.topLeft(), handle_rect.bottomRight())
            painter.drawLine(handle_rect.topLeft() + QPointF(0, handle_size/2), handle_rect.topRight() + QPointF(-handle_size/2, handle_size))
            
    def hoverEnterEvent(self, event):
        self.hovered = True; self.update(); super().hoverEnterEvent(event)
        
    def hoverLeaveEvent(self, event):
        self.hovered = False; self.resize_handle_hovered = False
        self.hovered_node_idx = -1; self.hovered_link_idx = -1
        self.setCursor(Qt.CursorShape.ArrowCursor); self.update(); super().hoverLeaveEvent(event)
        
    def mousePressEvent(self, event):
        if self._is_resize_handle(event.pos()):
            self.resizing = True
            self.resize_start_pos, self.resize_start_size = event.pos(), QSizeF(self.width, self.height)
            event.accept()
        
        if event.button() == Qt.MouseButton.LeftButton and self.scene():
            self.scene().is_dragging_item = True
        super().mousePressEvent(event)
            
    def mouseReleaseEvent(self, event):
        if self.resizing:
            self.resizing = False; event.accept()
        
        if self.scene():
            self.scene().is_dragging_item = False; self.scene()._clear_smart_guides()
        super().mouseReleaseEvent(event)
            
    def mouseMoveEvent(self, event):
        if self.resizing:
            delta = event.pos() - self.resize_start_pos
            self.width = max(400, self.resize_start_size.width() + delta.x())
            self.height = max(300, self.resize_start_size.height() + delta.y())
            self.generate_chart()
            self.prepareGeometryChange(); self.update()
            event.accept()
        else:
            super().mouseMoveEvent(event)
            
    def _is_resize_handle(self, pos):
        return QRectF(self.width - 10, self.height - 10, 10, 10).contains(pos)
        
    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionChange and self.scene() and self.scene().is_dragging_item:
            parent = self.parentItem()
            if parent and isinstance(parent, Container): parent.updateGeometry()
            return self.scene().snap_position(self, value)

        if change == QGraphicsItem.ItemPositionHasChanged and self.scene():
            self.scene().nodeMoved(self)

        return super().itemChange(change, value)