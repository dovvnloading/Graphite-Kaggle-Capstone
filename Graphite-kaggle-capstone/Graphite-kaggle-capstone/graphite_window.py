from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QToolBar,
    QToolButton, QLineEdit, QPushButton, QMessageBox, QSizePolicy, QLabel, QComboBox,
    QFileDialog
)
from PySide6.QtCore import Qt, QSize, QPointF, QTimer
from PySide6.QtGui import QKeySequence, QGuiApplication, QCursor, QShortcut, QIcon
import qtawesome as qta
import json
import os
import re

from graphite_styles import StyleSheet
from graphite_widgets import LoadingAnimation, SpellCheckLineEdit
from graphite_ui_components import NotificationBanner, DocumentViewerPanel
from graphite_canvas_items import Note, Frame, Container
from graphite_node import ChatNode, CodeNode, DocumentNode, ImageNode, ThinkingNode
from graphite_pycoder import PyCoderNode, PyCoderMode
from graphite_web import WebNode
from graphite_core import ChatSessionManager
from graphite_plugin_portal import PluginPortal
from graphite_agents import (
    ChatAgent, ExplainerAgent, KeyTakeawayAgent, ChartDataAgent, GroupSummaryAgent,
    ChatWorkerThread, KeyTakeawayWorkerThread, ExplainerWorkerThread, ChartWorkerThread,
    GroupSummaryWorkerThread, ImageGenerationAgent, ImageGenerationWorkerThread, CodeExecutionWorker,
    PyCoderAgentWorker, PyCoderExecutionWorker, WebWorkerThread, OrchestratorAgent, OrchestratorWorkerThread,
    OrchestratorExecutionWorker, SynthesisWorkerThread
)
from graphite_file_handler import FileHandler
import graphite_config as config
import api_provider
from graphite_config import get_current_palette
from graphite_conversation_node import ConversationNode
from graphite_reasoning import ReasoningNode
from graphite_orchestrator import OrchestratorNode, MemoryBankNode, SynthesisNode
from graphite_html_view import HtmlViewNode
from graphite_dialogs import ChatLibraryDialog, HelpDialog
from graphite_command_palette import CommandManager, CommandPaletteDialog



BASE_SYSTEM_PROMPT = """
* You are Graphite Assistant, a helpful AI integrated within a node-based productivity application named Graphite.
* You are a general-purpose assistant capable of helping with a wide variety of topics.
* If the user asks about the Graphite application specifically, you must use the knowledge base below to provide accurate guidance. Do not invent features or shortcuts. If a feature is not listed, state that it does not exist.

--- GRAPHITE APPLICATION KNOWLEDGE BASE ---

**1. CORE ARCHITECTURE: The Node Graph**
Graphite is a visual canvas where ideas are structured as a graph of interconnected nodes.
*   **Nodes:** These are the primary containers for information.
    *   `ChatNode`: The most common node, representing a message from the user (green outline) or the AI (blue outline).
    *   `CodeNode`: A block for displaying formatted code with syntax highlighting, linked to a parent `ChatNode`.
    *   `ImageNode`: Displays an image, either attached by the user or generated by the AI.
    *   `DocumentNode`: Displays text content from an attached file (e.g., .txt, .pdf, .docx).
    *   `Note`: A floating sticky note for annotations (`Ctrl+N`).
    *   `PyCoderNode`, `WebNode`, etc.: Specialized plugin nodes for advanced tasks.

*   **Connections:** Lines representing relationships between nodes.

**2. USER INTERFACE & WORKFLOWS**

**A. Main Canvas Interaction**
*   **Panning:** Hold the **Middle Mouse Button** and drag. Alternatively, use **W, A, S, D** keys.
*   **Zooming:** Hold **Ctrl** and use the **Mouse Wheel**, or use the **Q** and **E** keys.
*   **Zoom to Selection:** Hold **Shift** and drag to draw a box. Releasing the mouse will zoom the view to fit that box.
*   **Selection:** Click an item to select it. Drag on an empty area to create a selection box for multiple items.
*   **Move Items:** Click and drag any selected item or group of items to reposition them on the canvas.

**B. Main Toolbar (Top of Window)**
*   **Organize:** Automatically arranges all nodes into a clean, hierarchical tree layout.
*   **Agent Tools:** A dropdown menu to access and create specialized agent nodes.

**C. Input Bar (Bottom of Window)**
*   **Attach File:** Click the **Paperclip Icon** to attach an image or document (`.pdf`, `.docx`, `.txt`, etc.). The file's content will be included for the AI's context in your next message.
*   **Send Message:** Type your message and press **Enter** to send.

**3. AGENT TOOLS (PLUGINS)**
Plugins create new, specialized nodes that branch off the main conversation. They are accessed from the "Agent Tools" dropdown in the toolbar.
*   **Agent Orchestrator:** Adds an `OrchestratorNode`. This is a "conductor" agent that can create and manage a multi-step plan to achieve a high-level goal. It automates other tools like the Web Researcher and Py-Coder.
*   **Memory Bank:** Adds a `MemoryBankNode`. This is a simple key-value store that allows the Orchestrator to save and retrieve information between steps, creating a memory for the workflow.
*   **Text Synthesizer:** Adds a `SynthesisNode`. This agent takes instructions and a body of text (often from a previous step) and generates a new text, such as a summary, report, or reformatted document. It is the primary "writing" tool for the Orchestrator.
*   **System Prompt:** Creates a special `Note` that overrides the default AI personality for an entire conversation branch. It's used to give custom instructions or personas to the AI.
*   **Py-Coder:** Adds a `PyCoderNode` that acts as a Python coding environment for executing code, debugging, and getting AI analysis.
*   **Graphite-Web:** Adds a `WebNode` with real-time internet access to search for information and provide synthesized summaries with sources.
*   **Conversation Node:** Adds a `ConversationNode` for creating a self-contained, linear chat that doesn't affect the main graph's history.
*   **Graphite-Reasoning:** Adds a `ReasoningNode`. This is a multi-step "plan, reason, critique" agent designed to solve complex problems that a single prompt might fail on.
*   **HTML Renderer:** Adds an `HtmlViewNode` to render live previews of HTML code, often from a `CodeNode` or a `Py-Coder` output.
"""

class ChatWindow(QMainWindow):
    """
    The main application window for Graphite.
    """
    def __init__(self):
        super().__init__()
        from graphite_view import ChatView
        
        self.file_handler = FileHandler()
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowType.WindowContextHelpButtonHint | Qt.WindowType.WindowCloseButtonHint)
        self.setGeometry(100, 100, 1200, 800)
        self._initial_show_complete = False

        self.setWindowTitle("Graphite - AI Agents Capstone")

        # Set a placeholder icon path, can be removed if not needed.
        icon_path = r"C:\Users\Admin\source\repos\Graphite-kaggle-capstone\assets\graphite.ico" 
        self.setWindowIcon(QIcon(str(icon_path)))

        self.session_manager = ChatSessionManager(self)
        self.plugin_portal = PluginPortal(self)
        self.agent = ChatAgent("Graphite Assistant", BASE_SYSTEM_PROMPT)

        self.auto_save_timer = QTimer(self)
        self.auto_save_timer.setSingleShot(True)
        self.auto_save_timer.setInterval(2500)
        self.auto_save_timer.timeout.connect(self.session_manager.save_current_chat)

        self.chat_thread = None
        self.takeaway_thread = None
        self.explainer_thread = None
        self.chart_thread = None
        self.group_summary_thread = None
        self.image_gen_thread = None
        self.code_exec_thread = None
        self.pycoder_agent_thread = None
        self.pycoder_exec_thread = None
        self.web_worker_thread = None
        self.orchestrator_thread = None 
        self.orchestrator_exec_thread = None
        self.synthesis_thread = None

        self.container = QWidget()
        container_layout = QVBoxLayout(self.container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(0)

        content_widget = QWidget()
        content_layout = QHBoxLayout(content_widget)
        content_layout.setContentsMargins(0, 0, 0, 0)
        content_layout.setSpacing(0)

        self.doc_viewer_panel = DocumentViewerPanel(self)
        self.doc_viewer_panel.close_requested.connect(self.hide_document_view)
        self.doc_viewer_panel.setVisible(False)
        content_layout.addWidget(self.doc_viewer_panel)

        self.chat_view = ChatView(self)
        self.chat_view.setAcceptDrops(True)
        self.chat_view.scene().scene_changed.connect(self._trigger_auto_save)
        content_layout.addWidget(self.chat_view)
        
        # Expose pin_overlay to window so ChatScene can find it via self.window.pin_overlay
        self.pin_overlay = self.chat_view.pin_overlay

        self.toolbar = QToolBar()
        self.setup_toolbar(self.toolbar)
        container_layout.addWidget(self.toolbar)

        container_layout.addWidget(content_widget)

        input_widget = QWidget()
        input_layout = QHBoxLayout(input_widget)
        input_layout.setContentsMargins(8, 8, 8, 8)
        
        self.attached_image_path = None
        self.attached_document_path = None
        self.attach_file_btn = QPushButton()
        self.attach_file_btn.setIcon(qta.icon('fa5s.paperclip', color='#cccccc'))
        self.attach_file_btn.setToolTip("Attach a file (image or document)")
        self.attach_file_btn.setFixedSize(40, 40)
        self.attach_file_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.attach_file_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent; border: 1px solid #3f3f3f;
                border-radius: 20px; padding: 10px;
            }
            QPushButton:hover { background-color: #3f3f3f; }
        """)
        self.attach_file_btn.clicked.connect(self.attach_file)

        self.message_input = SpellCheckLineEdit()
        self.message_input.setPlaceholderText("Type your message...")
        self.message_input.returnPressed.connect(self.send_message)
        
        self.send_button = QPushButton()
        self.send_button.setToolTip("Send message")
        self.send_button.setFixedSize(40, 40)
        
        input_layout.addWidget(self.attach_file_btn)
        input_layout.addWidget(self.message_input)
        input_layout.addWidget(self.send_button)
        
        bottom_container = QWidget()
        bottom_layout = QVBoxLayout(bottom_container)
        bottom_layout.setContentsMargins(0,0,0,0)
        bottom_layout.setSpacing(0)
        bottom_layout.addWidget(input_widget)
        
        self.notification_banner = NotificationBanner(self)
        bottom_layout.addWidget(self.notification_banner)

        container_layout.addWidget(bottom_container)

        self.setCentralWidget(self.container)
        self._update_themed_styles()
        self.send_button.clicked.connect(self.send_message)

        self.current_node = None
        self.loading_animation = None
        
        # --- Command Palette Setup ---
        self.command_manager = CommandManager()
        self.register_commands()
        
        self.command_palette_shortcut = QShortcut(QKeySequence("Ctrl+K"), self)
        self.command_palette_shortcut.activated.connect(self.open_command_palette)
        # -----------------------------

        self.new_chat_shortcut = QShortcut(QKeySequence("Ctrl+T"), self)
        self.new_chat_shortcut.activated.connect(self.new_chat)
        self.frame_shortcut = QShortcut(QKeySequence("Ctrl+G"), self)
        self.frame_shortcut.activated.connect(self.chat_view.scene().createFrame)
        self.container_shortcut = QShortcut(QKeySequence("Ctrl+Shift+G"), self)
        self.container_shortcut.activated.connect(self.chat_view.scene().createContainer)

        self.library_shortcut = QShortcut(QKeySequence("Ctrl+L"), self)
        self.library_shortcut.activated.connect(self.show_library)

        self.nav_up_shortcut = QShortcut(QKeySequence("Ctrl+Up"), self)
        self.nav_up_shortcut.activated.connect(self._navigate_up)
        self.nav_down_shortcut = QShortcut(QKeySequence("Ctrl+Down"), self)
        self.nav_down_shortcut.activated.connect(self._navigate_down)
        self.nav_left_shortcut = QShortcut(QKeySequence("Ctrl+Left"), self)
        self.nav_left_shortcut.activated.connect(self._navigate_left)
        self.nav_right_shortcut = QShortcut(QKeySequence("Ctrl+Right"), self)
        self.nav_right_shortcut.activated.connect(self._navigate_right)

        screen = QGuiApplication.primaryScreen().geometry()
        size = self.geometry()
        self.move(int((screen.width() - size.width()) / 2),
                 int((screen.height() - size.height()) / 2))
        
    def register_commands(self):
        """Registers application-wide commands with the CommandManager."""
        self.command_manager.register_command("New Chat", ["start new", "clear"], self.new_chat)
        self.command_manager.register_command("Open Library", ["load chat", "history"], self.show_library)
        self.command_manager.register_command("Save Chat", ["save project"], self.session_manager.save_current_chat)
        self.command_manager.register_command("Organize Canvas", ["layout", "auto arrange"], lambda: self.chat_view.scene().organize_nodes())
        self.command_manager.register_command("Create Frame", ["group"], self.chat_view.scene().createFrame)
        self.command_manager.register_command("Create Container", ["smart group"], self.chat_view.scene().createContainer)
        self.command_manager.register_command("Add Note", ["sticky note", "comment"], self._add_note_command)
        self.command_manager.register_command("Zoom In", ["magnify"], lambda: self.chat_view.scale(1.1, 1.1))
        self.command_manager.register_command("Zoom Out", ["shrink"], lambda: self.chat_view.scale(0.9, 0.9))
        self.command_manager.register_command("Reset Zoom", ["100%"], self.chat_view.reset_zoom)
        self.command_manager.register_command("Fit All", ["see all", "center"], self.chat_view.fit_all)
        self.command_manager.register_command("Toggle Pins", ["show pins", "navigation"], lambda: self.chat_view.toggle_pins(not self.chat_view.pin_overlay.isVisible()))
        self.command_manager.register_command("Open Help", ["documentation", "shortcuts", "guide"], self.show_help)

    def _add_note_command(self):
        """Adds a note at the current mouse cursor position."""
        view_pos = self.chat_view.mapFromGlobal(QCursor.pos())
        scene_pos = self.chat_view.mapToScene(view_pos)
        self.chat_view.scene().add_note(scene_pos)

    def open_command_palette(self):
        """Opens the Command Palette dialog."""
        commands = self.command_manager.get_available_commands()
        dialog = CommandPaletteDialog(commands, self)
        # Center the dialog relative to the main window
        dialog.move(self.geometry().center() - dialog.rect().center())
        
        if dialog.exec():
            cmd = dialog.get_selected_command()
            if cmd:
                cmd['callback']()

    def show_help(self):
        """Opens the Help dialog."""
        dialog = HelpDialog(self)
        dialog.show()

    def _trigger_auto_save(self):
        """Starts or restarts the auto-save debounce timer."""
        scene = self.chat_view.scene()
        if scene.nodes or scene.code_nodes or scene.image_nodes or scene.document_nodes:
            self.auto_save_timer.start()

    def _update_themed_styles(self):
        palette = get_current_palette()
        bg_color = palette.SELECTION
        
        brightness = (bg_color.red() * 299 + bg_color.green() * 587 + bg_color.blue() * 114) / 1000
        icon_color = "black" if brightness > 128 else "white"

        self.send_button.setIcon(qta.icon('fa5s.paper-plane', color=icon_color))
        
        main_color_str = bg_color.name()
        hover_color_str = bg_color.lighter(110).name()
        pressed_color_str = bg_color.darker(110).name()

        self.send_button.setStyleSheet(f"""
            QPushButton {{
                background-color: {main_color_str}; border: none;
                border-radius: 20px; padding: 10px;
            }}
            QPushButton:hover {{ background-color: {hover_color_str}; }}
            QPushButton:pressed {{ background-color: {pressed_color_str}; }}
        """)

        if self.attached_image_path or self.attached_document_path:
            icon_name = 'fa5s.image' if self.attached_image_path else 'fa5s.file-alt'
            self.attach_file_btn.setIcon(qta.icon(icon_name, color=main_color_str))
        else:
             self.attach_file_btn.setIcon(qta.icon('fa5s.paperclip', color='#cccccc'))

    def on_theme_changed(self):
        self._update_themed_styles()
        if self.chat_view and self.chat_view.scene():
            self.chat_view.scene().update()
            self.chat_view.viewport().update()

    def start_with_prompt(self, prompt: str):
        if prompt:
            self.message_input.setText(prompt)
            QTimer.singleShot(100, self.send_message)

    def showEvent(self, event):
        super().showEvent(event)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if hasattr(self, 'notification_banner') and self.notification_banner.isVisible():
            parent_width = self.width()
            self.notification_banner.setGeometry(
                0, self.height() - self.notification_banner.height(),
                parent_width, self.notification_banner.height()
            )
        if hasattr(self, 'chat_view') and hasattr(self.chat_view, '_update_overlay_positions'):
            self.chat_view._update_overlay_positions()
        
    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
             if self.attached_image_path or self.attached_document_path:
                self.clear_attachment()
        elif event.modifiers() & Qt.KeyboardModifier.ControlModifier:
            if event.key() == Qt.Key.Key_N:
                view_pos = self.chat_view.mapFromGlobal(QCursor.pos())
                scene_pos = self.chat_view.mapToScene(view_pos)
                self.chat_view.scene().add_note(scene_pos)
        elif event.key() == Qt.Key.Key_Delete:
            self.chat_view.scene().deleteSelectedItems()
        else:
            super().keyPressEvent(event)
        
    def show_library(self):
        """Opens the chat library dialog."""
        library_dialog = ChatLibraryDialog(self.session_manager, self)
        library_dialog.show()

    def setup_toolbar(self, toolbar):
        toolbar.setIconSize(QSize(20, 20))
        toolbar.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)
        toolbar.setStyleSheet("""
            QToolBar { spacing: 4px; padding: 4px; }
            QToolButton {
                color: white; background: transparent; border: none; border-radius: 4px;
                padding: 6px; margin: 2px; font-size: 12px;
            }
            QToolButton:hover { background: rgba(255, 255, 255, 0.1); }
            QToolButton:pressed { background: rgba(0, 0, 0, 0.2); }
            QToolButton#actionButton:hover { color: #3498db; }
            QToolButton#helpButton:hover { border-color: #9b59b6; color: #9b59b6; }
        """)
        
        # Reorganized Order:
        # 1. Library
        # 2. Pins
        # 3. Organize
        # 4. Controls
        # 5. Separator
        # 6. Fit All
        # 7. Reset
        # 8. Zoom In
        # 9. Zoom Out
        # 10. Help
        # 11. Spacer
        # 12. Plugins Combo

        library_btn = QToolButton()
        library_btn.setText("Library")
        library_btn.setObjectName("actionButton")
        library_btn.setToolTip("Open Chat Library (Ctrl+L)")
        library_btn.clicked.connect(self.show_library)
        toolbar.addWidget(library_btn)

        pins_btn = QToolButton()
        pins_btn.setText("Pins")
        pins_btn.setCheckable(True)
        pins_btn.setToolTip("Toggle Navigation Pins Overlay")
        pins_btn.toggled.connect(self.chat_view.toggle_pins)
        # Ensure button unchecks if overlay is closed via UI
        self.chat_view.pin_overlay.closed.connect(lambda: pins_btn.setChecked(False))
        toolbar.addWidget(pins_btn)

        organize_btn = QToolButton()
        organize_btn.setText("Organize")
        organize_btn.setObjectName("actionButton")
        organize_btn.clicked.connect(lambda: self.chat_view.scene().organize_nodes())
        toolbar.addWidget(organize_btn)

        toggle_overlays_btn = QToolButton()
        toggle_overlays_btn.setText("Controls")
        toggle_overlays_btn.setToolTip("Show/Hide View Controls")
        toggle_overlays_btn.setCheckable(True)
        toggle_overlays_btn.setChecked(False)
        toggle_overlays_btn.toggled.connect(self.chat_view.toggle_overlays_visibility)
        
        # Ensure button unchecks if panel is closed via its own 'x' button
        if hasattr(self.chat_view, 'controls_panel'):
            self.chat_view.controls_panel.closed.connect(lambda: toggle_overlays_btn.setChecked(False))
            
        toolbar.addWidget(toggle_overlays_btn)

        toolbar.addSeparator()

        fit_btn = QToolButton()
        fit_btn.setText("Fit All")
        fit_btn.clicked.connect(self.chat_view.fit_all)
        toolbar.addWidget(fit_btn)

        reset_btn = QToolButton()
        reset_btn.setText("Reset")
        reset_btn.clicked.connect(self.chat_view.reset_zoom)
        toolbar.addWidget(reset_btn)

        zoom_in_btn = QToolButton()
        zoom_in_btn.setText("Zoom In")
        zoom_in_btn.clicked.connect(lambda: self.chat_view.scale(1.1, 1.1))
        toolbar.addWidget(zoom_in_btn)

        zoom_out_btn = QToolButton()
        zoom_out_btn.setText("Zoom Out")
        zoom_out_btn.clicked.connect(lambda: self.chat_view.scale(0.9, 0.9))
        toolbar.addWidget(zoom_out_btn)

        help_btn = QToolButton()
        help_btn.setText("Help")
        help_btn.setObjectName("helpButton")
        help_btn.setToolTip("Open Help Dialog")
        help_btn.clicked.connect(self.show_help)
        toolbar.addWidget(help_btn)

        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        toolbar.addWidget(spacer)
        
        self.plugins_combo = QComboBox()
        self.plugins_combo.setMinimumWidth(200) # Increased width for new plugin name
        self.plugins_combo.addItem("Agent Tools")
        
        available_plugins = self.plugin_portal.get_plugins()
        if available_plugins:
            for plugin in available_plugins:
                self.plugins_combo.addItem(plugin['name'])
        else:
            self.plugins_combo.addItem("No plugins available")
            self.plugins_combo.model().item(1).setEnabled(False)
            
        self.plugins_combo.activated.connect(self._on_plugin_selected)
        toolbar.addWidget(self.plugins_combo)

    def _on_plugin_selected(self, index):
        if index == 0:
            return

        plugin_name = self.plugins_combo.itemText(index)
        self.plugin_portal.execute_plugin(plugin_name)

        self.plugins_combo.setCurrentIndex(0)

    def show_document_view(self, node):
        if isinstance(node, ChatNode):
            self.doc_viewer_panel.set_document_content(node.text)
            self.doc_viewer_panel.setVisible(True)

    def hide_document_view(self):
        self.doc_viewer_panel.setVisible(False)

    def setCurrentNode(self, node):
        self.current_node = node
        text_content = ""
        if isinstance(node, ChatNode):
            text_content = node.text if node.text else "[Attachment/Content Node]"
        elif isinstance(node, PyCoderNode): text_content = "Py-Coder Analysis"
        elif isinstance(node, WebNode): text_content = "Web Search Node"
        elif isinstance(node, SynthesisNode): text_content = "Text Synthesizer"
        elif isinstance(node, Note) and node.is_summary_note:
            text_content = "[Summary Note]"
            self.message_input.setPlaceholderText("Cannot respond to a summary note.")
            return

        if text_content:
            self.message_input.setPlaceholderText(f"Responding to: {text_content[:30]}...")
        else:
            self.message_input.setPlaceholderText("Type your message...")
        
    def attach_file(self):
        supported_images = "*.png *.jpg *.jpeg *.webp"
        supported_docs = " ".join(self.file_handler.SUPPORTED_EXTENSIONS)
        
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Select a File", "",
            f"All Supported Files ({supported_images} {supported_docs});;Image Files ({supported_images});;Document Files ({supported_docs})"
        )
        if file_path:
            self.stage_dropped_file(file_path)

    def stage_dropped_file(self, file_path):
        file_extension = os.path.splitext(file_path)[1].lower()
        image_extensions = ['.png', '.jpg', '.jpeg', '.webp']
        
        self.clear_attachment()

        if file_extension in image_extensions:
            self.attached_image_path = file_path
            icon = 'fa5s.image'
            attachment_type = "Image"
        elif file_extension in self.file_handler.SUPPORTED_EXTENSIONS:
            self.attached_document_path = file_path
            icon = 'fa5s.file-alt'
            attachment_type = "Document"
        else:
            self.notification_banner.show_message(f"Unsupported file type: {file_extension}", 5000)
            return

        file_name = os.path.basename(file_path)
        icon_color = get_current_palette().SELECTION.name()
        self.attach_file_btn.setIcon(qta.icon(icon, color=icon_color))
        self.attach_file_btn.setToolTip(f"{attachment_type} Attached: {file_name}\nClick to change, or press Esc to clear.")

    def clear_attachment(self):
        self.attached_image_path = None
        self.attached_document_path = None
        self.attach_file_btn.setIcon(qta.icon('fa5s.paperclip', color='#cccccc'))
        self.attach_file_btn.setToolTip("Attach a file (image or document)")

    def send_message(self):
        message = self.message_input.text().strip()
        
        if not message and not self.attached_image_path and not self.attached_document_path:
            return
        
        self.message_input.setEnabled(False)
        self.send_button.setEnabled(False)
        self.attach_file_btn.setEnabled(False)
        
        history = self.current_node.conversation_history[:] if self.current_node else []
        
        user_node_text = message if message else ""
        llm_content_parts = []
        
        if user_node_text:
            llm_content_parts.append({'type': 'text', 'text': user_node_text})

        user_node = self.chat_view.scene().add_chat_node(
            user_node_text if user_node_text else "[Attachment]",
            is_user=True, 
            parent_node=self.current_node,
            conversation_history=history
        )
        
        if self.attached_image_path:
            try:
                with open(self.attached_image_path, 'rb') as f:
                    image_bytes = f.read()
                self.chat_view.scene().add_image_node(image_bytes, user_node, prompt=user_node_text)
                llm_content_parts.append({'type': 'image_bytes', 'data': image_bytes})
            except IOError as e:
                self.handle_error(f"Could not read image file: {e}")
                user_node.scene().delete_chat_node(user_node)
                return
        
        if self.attached_document_path:
            file_name = os.path.basename(self.attached_document_path)
            doc_content, error = self.file_handler.read_file(self.attached_document_path)
            if error:
                self.handle_error(error)
                user_node.scene().delete_chat_node(user_node)
                return
            
            self.chat_view.scene().add_document_node(title=file_name, content=doc_content, parent_user_node=user_node)
            formatted_doc = f"--- ATTACHED DOCUMENT: {file_name} ---\n{doc_content}\n--- END OF DOCUMENT ---"
            llm_content_parts.append({'type': 'text', 'text': formatted_doc})

        payload_for_llm = llm_content_parts if len(llm_content_parts) > 1 else llm_content_parts[0]['text']

        self.loading_animation = LoadingAnimation()
        self.chat_view.scene().addItem(self.loading_animation)
        anim_pos = QPointF(user_node.pos().x() + user_node.width + 50, user_node.pos().y() + user_node.height / 2)
        self.loading_animation.setPos(anim_pos)
        self.loading_animation.start()

        history_for_worker = history + [{'role': 'user', 'content': payload_for_llm}]
        user_node.conversation_history = history_for_worker
        
        self.chat_thread = ChatWorkerThread(self.agent, history_for_worker, self.current_node)
        self.chat_thread.finished.connect(lambda new_message: self.handle_response(new_message, user_node, history_for_worker))
        self.chat_thread.error.connect(self.handle_error)
        self.chat_thread.finished.connect(self.chat_thread.deleteLater)
        self.chat_thread.error.connect(self.chat_thread.deleteLater)
        self.chat_thread.start()

    def _parse_response(self, response_text):
        parts = []
        think_tag_pattern=re.compile(r"<(think|thinking)>(.*?)</\1>",re.DOTALL|re.IGNORECASE)
        fallback_reasoning_pattern=re.compile(r"--- REASONING ---\s*(.*?)\s*--- END REASONING ---",re.DOTALL|re.IGNORECASE)
        code_block_tag_pattern=re.compile(r"<code_block>([\s\S]*?)</code_block>",re.IGNORECASE)
        code_fence_pattern=re.compile(r"```(\w*)\s*\n?([\s\S]*?)\s*```")
        remaining_text=response_text
        thinking_match=think_tag_pattern.search(remaining_text)
        if thinking_match:
            thinking_content=thinking_match.group(2).strip()
            parts.append({'type':'thinking','content':thinking_content})
            remaining_text=remaining_text.replace(thinking_match.group(0),"").strip()
        else:
            fallback_match=fallback_reasoning_pattern.search(remaining_text)
            if fallback_match:
                thinking_content=fallback_match.group(1).strip()
                parts.append({'type':'thinking','content':thinking_content})
                remaining_text=remaining_text.replace(fallback_match.group(0),"").strip()
        text_content=""
        code_snippets=[]
        language=""
        code_block_match=code_block_tag_pattern.search(remaining_text)
        if code_block_match:
            code_content_raw=code_block_match.group(1).strip()
            text_content=(remaining_text[:code_block_match.start()]+remaining_text[code_block_match.end():]).strip()
            inner_matches=list(code_fence_pattern.finditer(code_content_raw))
            if inner_matches:
                language=inner_matches[0].group(1).strip()
                code_snippets=[m.group(2).strip() for m in inner_matches]
            else:
                code_snippets=[code_content_raw]
        else:
            matches=list(code_fence_pattern.finditer(remaining_text))
            if matches:
                language=matches[0].group(1).strip()
                code_snippets=[m.group(2).strip() for m in matches]
                text_content=code_fence_pattern.sub("",remaining_text).strip()
            else:
                text_content=remaining_text.strip()
        if text_content:
            parts.append({'type':'text','content':text_content})
        if code_snippets:
            combined_code="\n\n# --- Next Code Block ---\n\n".join(code_snippets).strip()
            if combined_code:
                parts.append({'type':'code','language':language,'content':combined_code})
        if not parts and response_text.strip():
            return[{'type':'text','content':response_text.strip()}]
        return parts

    def handle_response(self, new_assistant_message, user_node, history_before_assistant):
        if self.loading_animation:
            self.loading_animation.stop()
            self.chat_view.scene().removeItem(self.loading_animation)
            self.loading_animation=None
        full_history=history_before_assistant+[new_assistant_message]
        response_text=new_assistant_message['content']

        scene=self.chat_view.scene()
        parsed_parts=self._parse_response(response_text)
        text_content_parts=[part['content'] for part in parsed_parts if part['type']=='text']
        text_content="\n\n".join(text_content_parts)
        ai_node=None
        has_visible_content=any(p['type'] in['text','code'] for p in parsed_parts)
        if text_content or not has_visible_content:
            ai_node=scene.add_chat_node(text_content if text_content else "[Empty Response]",is_user=False,parent_node=user_node,conversation_history=full_history)
        parent_for_content=ai_node if ai_node else user_node
        last_created_node=ai_node
        for part in parsed_parts:
            if part['type']=='code':
                code_node=scene.add_code_node(part['content'],part['language'],parent_for_content)
                last_created_node=code_node
            elif part['type']=='thinking':
                thinking_node=scene.add_thinking_node(part['content'],parent_for_content)
                last_created_node=thinking_node
        self.current_node=last_created_node if last_created_node else user_node
        self.chat_view.centerOn(self.current_node)
        self.message_input.clear()
        self.message_input.setEnabled(True)
        self.send_button.setEnabled(True)
        self.attach_file_btn.setEnabled(True)
        self.clear_attachment()
        
    def handle_error(self, error_message):
        if self.loading_animation:
            self.loading_animation.stop()
            self.chat_view.scene().removeItem(self.loading_animation)
            self.loading_animation = None

        QMessageBox.critical(self, "Error", f"An error occurred: {error_message}")
        self.message_input.setEnabled(True)
        self.send_button.setEnabled(True)
        self.attach_file_btn.setEnabled(True)
        self.clear_attachment()
        
    def regenerate_node(self, node_to_regenerate):
        if not hasattr(node_to_regenerate, 'parent_node') or not node_to_regenerate.parent_node:
            QMessageBox.warning(self, "Cannot Regenerate", "This node has no parent and cannot be regenerated.")
            return

        history_for_worker = node_to_regenerate.parent_node.conversation_history[:]
        self.message_input.setEnabled(False)
        self.send_button.setEnabled(False)

        self.loading_animation = LoadingAnimation()
        self.chat_view.scene().addItem(self.loading_animation)
        anim_pos = QPointF(node_to_regenerate.pos().x() + node_to_regenerate.width + 50, node_to_regenerate.pos().y() + node_to_regenerate.height / 2)
        self.loading_animation.setPos(anim_pos)
        self.loading_animation.start()

        self.chat_thread = ChatWorkerThread(self.agent, history_for_worker, node_to_regenerate.parent_node)
        self.chat_thread.finished.connect(lambda new_message: self.handle_regenerated_response(new_message, node_to_regenerate, history_for_worker))
        self.chat_thread.error.connect(self.handle_error)
        self.chat_thread.finished.connect(self.chat_thread.deleteLater)
        self.chat_thread.error.connect(self.chat_thread.deleteLater)
        self.chat_thread.start()

    def handle_regenerated_response(self, new_assistant_message, old_node, parent_history):
        try:
            new_response=new_assistant_message['content']
            if not new_response or not new_response.strip():
                QMessageBox.warning(self,"Regeneration Failed","The model returned an empty response. The original response has been kept.")
                return
            scene=self.chat_view.scene()
            if not old_node or not old_node.scene():return
            scene.remove_associated_content_nodes(old_node)
            parsed_parts=self._parse_response(new_response)
            text_content_parts=[p['content'] for p in parsed_parts if p['type']=='text']
            text_content="\n\n".join(text_content_parts)
            full_history_for_new_node=parent_history+[new_assistant_message]
            old_node.conversation_history=full_history_for_new_node
            old_node.update_content(text_content if text_content else "[Generated Content]")
            last_created_node=old_node
            for part in parsed_parts:
                if part['type']=='code':
                    code_node=scene.add_code_node(part['content'],part['language'],old_node)
                    last_created_node=code_node
                elif part['type']=='thinking':
                    thinking_node=scene.add_thinking_node(part['content'],old_node)
                    last_created_node=thinking_node
            scene.update_connections()
            self.current_node=last_created_node
            self.chat_view.centerOn(last_created_node)
        except Exception as e:
            self.handle_error(f"An error occurred during regeneration: {str(e)}")
        finally:
            if self.loading_animation:
                self.loading_animation.stop()
                self.chat_view.scene().removeItem(self.loading_animation)
                self.loading_animation=None
            self.message_input.setEnabled(True)
            self.send_button.setEnabled(True)

    def execute_orchestrator_node(self, orchestrator_node):
        goal = orchestrator_node.goal.strip()
        if not goal:
            orchestrator_node.set_error("Goal cannot be empty.")
            return

        orchestrator_node.set_running_state(True)
        orchestrator_node.set_status("Generating execution plan...")
        
        parent_node = orchestrator_node.parent_node
        history = parent_node.conversation_history[:] if parent_node and hasattr(parent_node, 'conversation_history') else []

        self.orchestrator_thread = OrchestratorWorkerThread(OrchestratorAgent(), goal, history, orchestrator_node)
        self.orchestrator_thread.plan_generated.connect(self._handle_plan_generation)
        self.orchestrator_thread.error.connect(self._handle_orchestrator_error)
        self.orchestrator_thread.finished.connect(self.orchestrator_thread.deleteLater)
        self.orchestrator_thread.start()

    def _handle_plan_generation(self, plan_json_str, orchestrator_node):
        try:
            plan = json.loads(plan_json_str)
            
            # Pass raw plan data to the node to generate visual cards
            if hasattr(orchestrator_node, 'create_step_cards_from_json'):
                orchestrator_node.create_step_cards_from_json(plan)
            else:
                # Fallback logic just in case
                markdown_plan = "### Execution Plan\n\n"
                for step in plan:
                    markdown_plan += f"**Step {step['step']}: {step['task']}**\n"
                    markdown_plan += f"- **Tool:** `{step['tool']}`\n"
                    markdown_plan += f"- **Input:** `{step['input']}`\n\n"
                orchestrator_node.set_plan(markdown_plan)
            
            orchestrator_node.set_status("Plan generated. Starting execution...")

            self.orchestrator_exec_thread = OrchestratorExecutionWorker(self.chat_view.scene(), plan, orchestrator_node)
            
            self.orchestrator_exec_thread.request_tool_node.connect(self._create_tool_node_for_worker)
            self.orchestrator_exec_thread.execute_tool.connect(self._execute_tool_for_worker)
            self.orchestrator_exec_thread.log_message.connect(orchestrator_node.append_log)
            self.orchestrator_exec_thread.step_started.connect(orchestrator_node.set_current_step)
            
            # Connect the new signal for granular card updates
            if hasattr(self.orchestrator_exec_thread, 'step_finished'):
                self.orchestrator_exec_thread.step_finished.connect(orchestrator_node.update_step_output)

            self.orchestrator_exec_thread.execution_finished.connect(
                lambda result: self._handle_orchestration_finished(result, orchestrator_node)
            )
            self.orchestrator_exec_thread.error.connect(
                lambda error_msg: self._handle_orchestrator_error(error_msg, orchestrator_node)
            )
            self.orchestrator_exec_thread.finished.connect(self.orchestrator_exec_thread.deleteLater)
            
            self.orchestrator_exec_thread.start()
            
        except json.JSONDecodeError as e:
            self._handle_orchestrator_error(f"Failed to parse the execution plan: {e}", orchestrator_node)
        except Exception as e:
            self._handle_orchestrator_error(f"An unexpected error occurred: {e}", orchestrator_node)

    def _create_tool_node_for_worker(self, tool_name, parent_node):
        scene = self.chat_view.scene()
        new_node = None
        if tool_name == "Web Researcher":
            new_node = scene.create_web_node(parent_node)
        elif tool_name == "Py-Coder":
            new_node = scene.create_pycoder_node(parent_node)
        elif tool_name == "Memory Bank":
            new_node = scene.create_memory_bank_node(parent_node)
        elif tool_name == "Synthesizer":
            new_node = scene.create_synthesis_node(parent_node)

        if new_node and self.orchestrator_exec_thread:
            self.orchestrator_exec_thread.tool_node_created.emit(new_node)
            
    def _execute_tool_for_worker(self, tool_node, input_data, step_data):
        if isinstance(tool_node, MemoryBankNode):
            output_key = step_data.get("output_key")
            if output_key:
                tool_node.set_value(output_key, input_data)
                result = input_data
            else:
                result = tool_node.get_value(input_data)
            
            if self.orchestrator_exec_thread and self.orchestrator_exec_thread.isRunning():
                self.orchestrator_exec_thread.tool_execution_finished.emit(result)
            return

        worker = tool_node.run_as_tool(input_data)
        worker.finished.connect(self._on_tool_worker_finished)
        worker.error.connect(self._on_tool_worker_error)
        worker.start()

    def _on_tool_worker_finished(self, result, node):
        output = ""
        if isinstance(node, WebNode):
            node.set_result(result['summary'], result['sources'])
            output = node.summary
        elif isinstance(node, PyCoderNode):
            if node.mode == PyCoderMode.MANUAL:
                # The first worker (CodeExecutionWorker) is done. Start the analysis worker.
                self.pycoder_agent_thread = PyCoderAgentWorker(node.get_code(), result, node)
                self.pycoder_agent_thread.finished.connect(self._on_tool_worker_finished)
                self.pycoder_agent_thread.error.connect(self._on_tool_worker_error)
                self.pycoder_agent_thread.start()
                return 
            else: # AI_DRIVEN or PyCoderAgentWorker result
                if isinstance(result, str): # This is an analysis result from PyCoderAgentWorker
                    node.set_ai_analysis(result)
                    output = result
                else: # This is a full execution result dict from PyCoderExecutionWorker
                    node.set_code(result.get('code', ''))
                    node.set_output(result.get('output', ''))
                    node.set_ai_analysis(result.get('analysis', ''))
                    output = node.ai_analysis_display.toPlainText()
        elif isinstance(node, SynthesisNode):
            node.set_output(result)
            output = result
        
        if hasattr(node, 'set_running_state'):
            node.set_running_state(False)
        
        if self.orchestrator_exec_thread and self.orchestrator_exec_thread.isRunning():
            self.orchestrator_exec_thread.tool_execution_finished.emit(output)

    def _on_tool_worker_error(self, error_message, node):
        node.set_error(error_message)
        if hasattr(node, 'set_running_state'):
            node.set_running_state(False)
        if self.orchestrator_exec_thread and self.orchestrator_exec_thread.isRunning():
            # Pass a formatted error string that includes the tool name
            self.orchestrator_exec_thread.error.emit(f"Tool '{type(node).__name__}' failed: {error_message}")
            
    def _handle_orchestration_finished(self, result, orchestrator_node):
        if orchestrator_node and orchestrator_node.scene():
            orchestrator_node.set_final_answer(result)
            
    def _handle_orchestrator_error(self, error_message, orchestrator_node):
        if orchestrator_node and orchestrator_node.scene():
            orchestrator_node.set_error(error_message)
            orchestrator_node.set_running_state(False)
    
    def generate_takeaway(self, node):
        try:
            self.loading_animation = LoadingAnimation()
            self.chat_view.scene().addItem(self.loading_animation)
            anim_pos = QPointF(node.pos().x() + node.width + 50, node.pos().y() + node.height / 2)
            self.loading_animation.setPos(anim_pos)
            self.loading_animation.start()
            
            self.takeaway_thread = KeyTakeawayWorkerThread(KeyTakeawayAgent(), node.text, node.scenePos())
            self.takeaway_thread.finished.connect(self.handle_takeaway_response)
            self.takeaway_thread.error.connect(self.handle_takeaway_error)
            self.takeaway_thread.finished.connect(self.takeaway_thread.deleteLater)
            self.takeaway_thread.error.connect(self.takeaway_thread.deleteLater)
            self.takeaway_thread.start()
            
        except Exception as e:
            self.handle_error(f"Error generating takeaway: {str(e)}")
            
    def handle_takeaway_response(self, response, node_pos):
        try:
            note_pos = QPointF(node_pos.x() + 400, node_pos.y())
            note = self.chat_view.scene().add_note(note_pos)
            note.width, note.content = 400, response
            note.color, note.header_color = "#2d2d2d", "#2ecc71"
            note._recalculate_geometry()
        except Exception as e:
            self.handle_error(f"Error creating takeaway note: {str(e)}")
        finally:
            if self.loading_animation:
                self.loading_animation.stop()
                self.chat_view.scene().removeItem(self.loading_animation)
                self.loading_animation = None
            
    def handle_takeaway_error(self, error_message):
        self.handle_error(f"Error generating takeaway: {error_message}")

    def generate_group_summary(self):
        try:
            scene = self.chat_view.scene()
            selected_nodes = [item for item in scene.selectedItems() if isinstance(item, ChatNode)]
            if len(selected_nodes) < 2:
                QMessageBox.warning(self, "Selection Error", "Please select two or more chat nodes to summarize.")
                return

            texts = [node.text for node in selected_nodes]
            
            avg_x, max_x, avg_y = 0, 0, 0
            for node in selected_nodes:
                pos = node.scenePos()
                avg_x += pos.x()
                max_x = max(max_x, pos.x() + node.width)
                avg_y += pos.y()
            note_pos = QPointF(max_x + 100, avg_y / len(selected_nodes))

            self.loading_animation = LoadingAnimation()
            scene.addItem(self.loading_animation)
            self.loading_animation.setPos(QPointF(note_pos.x() - 50, note_pos.y()))
            self.loading_animation.start()

            self.group_summary_thread = GroupSummaryWorkerThread(GroupSummaryAgent(), texts, note_pos, selected_nodes)
            self.group_summary_thread.finished.connect(self.handle_group_summary_response)
            self.group_summary_thread.error.connect(self.handle_group_summary_error)
            self.group_summary_thread.finished.connect(self.group_summary_thread.deleteLater)
            self.group_summary_thread.error.connect(self.group_summary_thread.deleteLater)
            self.group_summary_thread.start()

        except Exception as e:
            self.handle_error(f"Error generating group summary: {str(e)}")

    def handle_group_summary_response(self, response, note_pos, source_nodes):
        try:
            scene = self.chat_view.scene()
            note = scene.add_note(note_pos)
            note.content, note.color, note.header_color = response, "#2d2d2d", "#e67e22"
            note.width, note.is_summary_note = 450, True
            note._recalculate_geometry()

            for source_node in source_nodes:
                if source_node.scene() == scene:
                    from graphite_connections import GroupSummaryConnectionItem
                    conn = GroupSummaryConnectionItem(source_node, note)
                    scene.addItem(conn)
                    scene.group_summary_connections.append(conn)
        except Exception as e:
            self.handle_error(f"Error creating summary note: {str(e)}")
        finally:
            if self.loading_animation:
                self.loading_animation.stop()
                scene.removeItem(self.loading_animation)
                self.loading_animation = None

    def handle_group_summary_error(self, error_message):
        self.handle_error(f"Error during group summary generation: {error_message}")
        
    def generate_explainer(self, node):
        try:
            self.loading_animation = LoadingAnimation()
            self.chat_view.scene().addItem(self.loading_animation)
            anim_pos = QPointF(node.pos().x() + node.width + 50, node.pos().y() + node.height / 2)
            self.loading_animation.setPos(anim_pos)
            self.loading_animation.start()
            
            self.explainer_thread = ExplainerWorkerThread(ExplainerAgent(), node.text, node.scenePos())
            self.explainer_thread.finished.connect(self.handle_explainer_response)
            self.explainer_thread.error.connect(self.handle_explainer_error)
            self.explainer_thread.finished.connect(self.explainer_thread.deleteLater)
            self.explainer_thread.error.connect(self.explainer_thread.deleteLater)
            self.explainer_thread.start()
        except Exception as e:
            self.handle_error(f"Error generating explanation: {str(e)}")
            
    def handle_explainer_response(self, response, node_pos):
        try:
            note_pos = QPointF(node_pos.x() + 400, node_pos.y() + 100)
            note = self.chat_view.scene().add_note(note_pos)
            note.width, note.content = 400, response
            note.color, note.header_color = "#2d2d2d", "#9b59b6"
            note._recalculate_geometry()
        except Exception as e:
            self.handle_error(f"Error creating explainer note: {str(e)}")
        finally:
            if self.loading_animation:
                self.loading_animation.stop()
                self.chat_view.scene().removeItem(self.loading_animation)
                self.loading_animation = None
            
    def handle_explainer_error(self, error_message):
        self.handle_error(f"Error generating explanation: {error_message}")
        
    def generate_chart(self, node, chart_type):
        try:
            self.loading_animation = LoadingAnimation()
            self.chat_view.scene().addItem(self.loading_animation)
            anim_pos = QPointF(node.pos().x() + node.width + 50, node.pos().y() + node.height / 2)
            self.loading_animation.setPos(anim_pos)
            self.loading_animation.start()
        
            self.chart_thread = ChartWorkerThread(node.text, chart_type)
            self.chart_thread.finished.connect(self.handle_chart_data)
            self.chart_thread.error.connect(self.handle_error)
            self.chart_thread.finished.connect(self.chart_thread.deleteLater)
            self.chart_thread.error.connect(self.chart_thread.deleteLater)
            self.chart_thread.start()
        except Exception as e:
            self.handle_error(f"Error generating chart: {str(e)}")
        
    def handle_chart_data(self, data, chart_type):
        try:
            chart_data = json.loads(data)
            if "error" in chart_data:
                QMessageBox.warning(self, "Warning", chart_data["error"])
                return
            
            chart_pos = QPointF(self.current_node.scenePos().x() + 450, self.current_node.scenePos().y()) if self.current_node else QPointF(0, 0)
            self.chat_view.scene().add_chart(chart_data, chart_pos)
        except Exception as e:
            self.handle_error(f"Error creating chart: {str(e)}")
        finally:
            if self.loading_animation:
                self.loading_animation.stop()
                self.chat_view.scene().removeItem(self.loading_animation)
                self.loading_animation = None

    def generate_image(self, node):
        try:
            prompt = node.text
            if not prompt:
                QMessageBox.warning(self, "Cannot Generate Image", "The selected node has no text to use as a prompt.")
                return

            self.loading_animation = LoadingAnimation()
            self.chat_view.scene().addItem(self.loading_animation)
            anim_pos = QPointF(node.pos().x() + node.width + 50, node.pos().y() + node.height / 2)
            self.loading_animation.setPos(anim_pos)
            self.loading_animation.start()

            self.image_gen_thread = ImageGenerationWorkerThread(ImageGenerationAgent(), prompt)
            self.image_gen_thread.finished.connect(lambda image_bytes, p: self.handle_image_response(image_bytes, p, node))
            self.image_gen_thread.error.connect(self.handle_error)
            self.image_gen_thread.finished.connect(self.image_gen_thread.deleteLater)
            self.image_gen_thread.error.connect(self.image_gen_thread.deleteLater)
            self.image_gen_thread.start()
        except Exception as e:
            self.handle_error(f"Error initiating image generation: {str(e)}")

    def handle_image_response(self, image_bytes, prompt, parent_node):
        try:
            history = parent_node.conversation_history[:] + [{'role': 'user', 'content': prompt}, {'role': 'assistant', 'content': '[Image successfully generated]'}]

            ai_node = self.chat_view.scene().add_chat_node(
                f"Generated image for prompt: \"{prompt}\"",
                is_user=False, parent_node=parent_node, conversation_history=history
            )
            self.chat_view.scene().add_image_node(image_bytes, ai_node, prompt)
            self.chat_view.centerOn(ai_node)
        except Exception as e:
            self.handle_error(f"Failed to display generated image: {e}")
        finally:
            if self.loading_animation:
                self.loading_animation.stop()
                self.chat_view.scene().removeItem(self.loading_animation)
                self.loading_animation = None

    def execute_pycoder_node(self, pycoder_node):
        if pycoder_node.mode == PyCoderMode.AI_DRIVEN:
            input_data = pycoder_node.prompt_input.toPlainText()
        else: # MANUAL mode
            input_data = pycoder_node.code_input.toPlainText()
        
        if not input_data.strip():
            if pycoder_node.mode == PyCoderMode.AI_DRIVEN:
                pycoder_node.set_ai_analysis("Please enter a prompt.")
            else:
                pycoder_node.set_output("[No code to run]")
            return
            
        worker = pycoder_node.run_as_tool(input_data)
        worker.finished.connect(self._on_tool_worker_finished)
        worker.error.connect(self._on_tool_worker_error)
        worker.start()

    def _handle_code_execution_result(self, output, pycoder_node):
        pycoder_node.set_output(output)
        
        code = pycoder_node.get_code()
        self.pycoder_agent_thread = PyCoderAgentWorker(code, output, pycoder_node)
        self.pycoder_agent_thread.finished.connect(self._on_tool_worker_finished)
        self.pycoder_agent_thread.error.connect(self._on_tool_worker_error)
        self.pycoder_agent_thread.finished.connect(self.pycoder_agent_thread.deleteLater)
        self.pycoder_agent_thread.error.connect(self.pycoder_agent_thread.deleteLater)
        self.pycoder_agent_thread.start()

    def _handle_pycoder_analysis_result(self, analysis, pycoder_node):
        pycoder_node.set_ai_analysis(analysis)
        pycoder_node.set_running_state(False)
        self.setCurrentNode(pycoder_node)

    def _handle_ai_pycoder_result(self, result_dict, pycoder_node):
        analysis_text = result_dict.get('analysis', '')
        parent_history = pycoder_node.parent_node.conversation_history if pycoder_node.parent_node else []
        pycoder_node.conversation_history = parent_history + [{'role': 'assistant', 'content': analysis_text}]

        pycoder_node.set_code(result_dict.get('code', ''))
        pycoder_node.set_output(result_dict.get('output', ''))
        pycoder_node.set_ai_analysis(result_dict.get('analysis', ''))
        pycoder_node.set_running_state(False)
        self.setCurrentNode(pycoder_node)

    def _handle_pycoder_error(self, error_message, pycoder_node):
        pycoder_node.set_ai_analysis(f"An error occurred: {error_message}")
        pycoder_node.set_running_state(False)

    def execute_web_node(self, web_node):
        query = web_node.query.strip()
        if not query:
            web_node.set_error("Query cannot be empty.")
            return

        worker = web_node.run_as_tool(query)
        worker.finished.connect(self._on_tool_worker_finished)
        worker.error.connect(self._on_tool_worker_error)
        worker.start()

    def _navigate_to_node(self, node):
        if not node: return
        self.chat_view.scene().clearSelection()
        node.setSelected(True)
        self.setCurrentNode(node)
        self.chat_view.centerOn(node)

    def _navigate_up(self):
        current = self._get_single_selected_node()
        if current and hasattr(current, 'parent_node') and current.parent_node: self._navigate_to_node(current.parent_node)

    def _navigate_down(self):
        current = self._get_single_selected_node()
        if current and hasattr(current, 'children') and current.children:
            sorted_children = sorted(current.children, key=lambda c: c.pos().x())
            self._navigate_to_node(sorted_children[0])

    def _navigate_left(self):
        current = self._get_single_selected_node()
        if current and hasattr(current, 'parent_node') and current.parent_node:
            siblings = sorted(current.parent_node.children, key=lambda c: c.pos().x())
            try:
                current_index = siblings.index(current)
                if current_index > 0: self._navigate_to_node(siblings[current_index - 1])
            except ValueError: pass

    def _navigate_right(self):
        current = self._get_single_selected_node()
        if current and hasattr(current, 'parent_node') and current.parent_node:
            siblings = sorted(current.parent_node.children, key=lambda c: c.pos().x())
            try:
                current_index = siblings.index(current)
                if current_index < len(siblings) - 1: self._navigate_to_node(siblings[current_index + 1])
            except ValueError: pass

    def new_chat(self, parent_for_dialog=None):
        scene = self.chat_view.scene()
        if not scene.items() and not self.session_manager.current_chat_id:
            return True

        reply = QMessageBox.question(
            parent_for_dialog or self, 'New Chat',
            'Start a new chat? Any unsaved changes to the current session will be lost.',
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.auto_save_timer.stop()
            if hasattr(self, 'pin_overlay') and self.pin_overlay: self.pin_overlay.clear_pins()
            self.session_manager.current_chat_id = None
            scene.clear()
            self.current_node = None
            self.message_input.setPlaceholderText("Type your message...")
            self.setWindowTitle("Graphite - Competition Edition")
            return True
        return False

    def closeEvent(self, event):
        self.auto_save_timer.stop()
        scene = self.chat_view.scene()
        if scene.nodes or scene.conversation_nodes or scene.reasoning_nodes or scene.pycoder_nodes or scene.web_nodes:
            self.session_manager.save_current_chat()
            if self.session_manager.save_thread and self.session_manager.save_thread.isRunning():
                self.session_manager.save_thread.wait()
        super().closeEvent(event)
        
    def _get_single_selected_node(self):
        selected_items = self.chat_view.scene().selectedItems()
        valid_types = (ChatNode, PyCoderNode, WebNode, ConversationNode, ReasoningNode, OrchestratorNode, MemoryBankNode, SynthesisNode)
        if len(selected_items) == 1 and isinstance(selected_items[0], valid_types):
            return selected_items[0]
        return None

    def execute_reasoning_node(self, reasoning_node):
        prompt = reasoning_node.prompt.strip()
        if not prompt:
             reasoning_node.set_error("Prompt cannot be empty.")
             return
             
        budget = reasoning_node.thinking_budget
        reasoning_node.set_running_state(True)
        reasoning_node.clear_thoughts()
        reasoning_node.set_status("Planning...")
        
        # Start the reasoning worker thread
        from graphite_agents import ReasoningAgent, ReasoningWorkerThread
        self.reasoning_thread = ReasoningWorkerThread(ReasoningAgent(), prompt, budget)
        
        self.reasoning_thread.step_finished.connect(reasoning_node.append_thought)
        self.reasoning_thread.finished.connect(lambda result: self._on_reasoning_finished(result, reasoning_node))
        self.reasoning_thread.error.connect(lambda err: self._on_reasoning_error(err, reasoning_node))
        self.reasoning_thread.finished.connect(self.reasoning_thread.deleteLater)
        self.reasoning_thread.error.connect(self.reasoning_thread.deleteLater)
        
        self.reasoning_thread.start()

    def _on_reasoning_finished(self, final_answer, node):
        node.set_final_answer(final_answer)
        node.set_running_state(False)

    def _on_reasoning_error(self, error_msg, node):
        node.set_error(error_msg)
        node.set_running_state(False)

    def handle_conversation_node_request(self, convo_node, history):
        """
        Handles an AI request from a ConversationNode.
        """
        convo_node.set_input_enabled(False)
        
        # Use the standard chat thread but direct the output to the conversation node
        self.chat_thread = ChatWorkerThread(self.agent, history, convo_node.parent_node)
        self.chat_thread.finished.connect(lambda msg: self._on_convo_node_response(msg, convo_node))
        self.chat_thread.error.connect(lambda err: self._on_convo_node_error(err, convo_node))
        self.chat_thread.finished.connect(self.chat_thread.deleteLater)
        self.chat_thread.error.connect(self.chat_thread.deleteLater)
        self.chat_thread.start()

    def _on_convo_node_response(self, message, node):
        content = message.get('content', '')
        node.add_ai_message(content)

    def _on_convo_node_error(self, error_msg, node):
        node.add_ai_message(f"[Error: {error_msg}]")